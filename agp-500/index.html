<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>With AGP to 500&#43; white label apps</title>


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="/notes-vault/reveal-js/dist/reset.css">
<link rel="stylesheet" href="/notes-vault/reveal-js/dist/reveal.css"><link rel="stylesheet" href="/notes-vault/reveal-js/dist/theme/dracula.css" id="theme">
<link rel="stylesheet" href="/notes-vault/highlight-js/night-owl.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<style>
    .qr {
      padding: 20px;
      background-color: white;
      border: 2px solid #ccc;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .qr img {
        display: block;
        margin: 0 auto;
    }

    .qr-columns {
        display: flex;  
        justify-content: space-between;  
        gap: 20px;  
    }

    .qr-item {
        flex: 1;  
        text-align: center;  
    }

    .qr-item h3 {
        margin-bottom: 10px;  
    }

    .qr-item div {
        margin: 0 auto;  
        width: 200px;  
        height: 200px;  
    }
</style>

<style>
    .reveal pre {
        font-size: 0.45em;
    }
</style>
  </head>
  <body>
    
    <div class="reveal">
      <div class="slides">
  

    <section><h3 id="with-agp-to-500-white-label-apps">With AGP to 500+ white label apps</h3>
<figure><img src="/notes-vault/agp-500/images/grandroid.jpeg" width="200" height="200"><figcaption>
      <h4>Droidle</h4>
    </figcaption>
</figure>

</section><section>
<h3 id="disciple-media">Disciple Media</h3>
<figure><img src="/notes-vault/agp-500/images/disciple.png" width="274" height="517">
</figure>

</section><section>


<section data-shortcode-section>
<h3 id="project-structureplugin-setup">Project Structure/Plugin Setup</h3>
</section><section>
<ul>
<li>settings.gradle.kts</li>
<li>app/build.gradle</li>
<li><strong>app/devCommunity.gradle</strong></li>
<li><strong>build-logic/</strong>
<ul>
<li><strong>build.gradle.kts</strong></li>
<li><strong>settings.gradle.kts</strong></li>
<li><strong>android/build.gradle.kts</strong></li>
</ul>
</li>
</ul>
</section><section>
<h3 id="settingsgradlekts">settings.gradle.kts</h3>
<pre><code class="language-kotlin" data-line-numbers>includeBuild(&quot;build-logic&quot;)
</code></pre>
</section><section>
<h3 id="appbuildgradle">app/build.gradle</h3>
<pre><code class="language-kotlin" data-line-numbers>plugins {  
	id(&quot;build.logic.android.metadata&quot;)  
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="binary-pluginhttpsdocsgradleorgcurrentuserguidecustom_pluginshtmlseccustom_plugins_standalone_project"><a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:custom_plugins_standalone_project" target="_blank" rel="noopener">Binary Plugin</a></h3>
<pre><code class="language-kotlin" data-line-numbers="1-8">// build-logic/android/build.gradle.kts
plugins {  
	`java-gradle-plugin`  
}

dependencies {
	implementation(&quot;com.android.tools.build:gradle:8.6.1&quot;)
}

gradlePlugin {  
    plugins {  
        val pluginId = &quot;build.logic.android.metadata&quot;  
        create(pluginId) {  
            id = pluginId  
            implementationClass = &quot;my.package.AndroidMetadataPlugin&quot;  
            version = &quot;1.0&quot;  
            group = &quot;build.logic&quot;  
        }  
    }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="binary-pluginhttpsdocsgradleorgcurrentuserguidecustom_pluginshtmlseccustom_plugins_standalone_project-1"><a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:custom_plugins_standalone_project" target="_blank" rel="noopener">Binary Plugin</a></h3>
<pre><code class="language-kotlin" data-line-numbers="10-20">// build-logic/android/build.gradle.kts
plugins {  
	`java-gradle-plugin`  
}

dependencies {
	implementation(&quot;com.android.tools.build:gradle:8.6.1&quot;)
}

gradlePlugin {  
    plugins {  
        val pluginId = &quot;build.logic.android.metadata&quot;  
        create(pluginId) {  
            id = pluginId  
            implementationClass = &quot;my.package.AndroidMetadataPlugin&quot;  
            version = &quot;1.0&quot;  
            group = &quot;build.logic&quot;  
        }  
    }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="hooking-into-plugin">Hooking Into Plugin</h3>
<pre><code class="language-kotlin" data-line-numbers="1-5">import org.gradle.api.Plugin  
import org.gradle.api.Project  
  
abstract class AndroidMetadataPlugin : Plugin&lt;Project&gt; {  
    override fun apply(project: Project) {  
        project.pluginManager.withPlugin(&quot;com.android.application&quot;) {
           setupPlugin(project)
        }
    }  
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="hooking-into-plugin-1">Hooking Into Plugin</h3>
<pre><code class="language-kotlin" data-line-numbers="6-8">import org.gradle.api.Plugin  
import org.gradle.api.Project  
  
abstract class AndroidMetadataPlugin : Plugin&lt;Project&gt; {  
    override fun apply(project: Project) {  
        project.pluginManager.withPlugin(&quot;com.android.application&quot;) {
           setupPlugin(project)
        }
    }  
}
</code></pre>
</section><section>
<h3 id="peek-your-extension">Peek Your Extension</h3>
<pre><code class="language-kotlin" data-line-numbers="6-8,10-12">import org.gradle.kotlin.dsl.the
import com.android.build.gradle.AppExtension
import com.android.build.api.variant.ApplicationAndroidComponentsExtension

private fun setupPlugin(project: Project) = project.run {
	// android { compileSdk 34 }
	// Older API with a lot of tech debt ¯\_(ツ)_/¯
	the&lt;AppExtension&gt;().run {}
	
	// androidComponents { onVariants { } }
	// Latest API available since 2020
	the&lt;ApplicationAndroidComponentsExtension&gt;().run {} 
}
</code></pre>
</section><section>
<h3 id="why-new-api">Why new API?</h3>
<p><span class='fragment ' >Older plugin leaked abstractions and lacked a clear definition of which APIs were stable or experimental.</span></p>
<p><span class='fragment ' >Better compatibility with <a href="https://docs.gradle.org/current/userguide/lazy_configuration.html" target="_blank" rel="noopener">lazy configuration</a> based on <strong>Provider</strong>/<strong>Property</strong> types.</span></p>

</section>
</section><section>


<section data-shortcode-section>
<h3 id="loading-remote-configuration">Loading remote configuration</h3>
</section><section>
<h3 id="custom-extension">Custom Extension</h3>
<p>Enables API call authentication.</p>
<pre><code class="language-kotlin" data-line-numbers>abstract class DevCommunityExtension {
  interface ConfigCredentials {
    @get:Input
    val username: Property&lt;String&gt;
  
    @get:Input
    val password: Property&lt;String&gt;
  
    @get:Input
    val env: Property&lt;Env&gt;
  
    @get:Input
    @get:Optional
    val baseUrl: Property&lt;String&gt;
  }
}
</code></pre>
</section><section>
<h3 id="use-action-api-over-kotlin-lambdas">Use Action API Over Kotlin Lambdas</h3>
<pre><code class="language-kotlin" data-line-numbers>abstract class DevCommunityExtension {
    @get:Input
    abstract val name: Property&lt;String&gt;
    
    @get:Nested
    abstract val configCredentials: ConfigCredentials

    @Suppress(&quot;unused&quot;) // Public API
    fun configCredentials(action: Action&lt;ConfigCredentials&gt;) {
        action.execute(configCredentials)
    }
</code></pre>
</section><section>
<h3 id="register-extension">Register Extension</h3>
<pre><code class="language-kotlin" data-line-numbers>project.extensions.create(
  &quot;devCommunity&quot;, 
  DevCommunityExtension::class.java
)
</code></pre>
</section><section>
<h3 id="appbuildgradle">app/build.gradle</h3>
<pre><code class="language-groovy" data-line-numbers>plugins {
    id(&quot;com.android.application&quot;)
    id(&quot;build.logic.android.metadata&quot;)
}

def customCommunity = file(&quot;devCommunity.gradle&quot;)
if (customCommunity.exists()) {
  apply(from: customCommunity)
}
</code></pre>
</section><section>
<h3 id="appdevcommunitygradle">app/devCommunity.gradle</h3>
<pre><code class="language-groovy" data-line-numbers>devCommunity {
    name = &quot;androidbudapest&quot;
    configCredentials {
        username = &quot;dev&quot;
        password = &quot;qwerty&quot;
    }
}
</code></pre>
</section><section>
<h3 id="gitignore">.gitignore</h3>
<pre><code class="language-gitignore" data-line-numbers>devCommunity.gradle
</code></pre>
</section><section>
<h3 id="definition-of-loadremoteconfig">Definition of LoadRemoteConfig</h3>
<pre><code class="language-kotlin" data-line-numbers>abstract class LoadRemoteConfig : DefaultTask() {
    @get:Nested
    abstract var configCredentials: DevCommunityExtension.ConfigCredentials

    @get:Input
    abstract val community: Property&lt;String&gt;

    @get:OutputFile
    abstract val outArtifact: RegularFileProperty
    
    @TaskAction
    fun execute() { /* ... */ }
}
</code></pre>
</section><section>
<h3 id="retrofit-api-service">Retrofit API Service</h3>
<pre><code class="language-kotlin" data-line-numbers>internal interface NativeConfigApi {
    @GET(&quot;/my/api/{communityName}&quot;)
    fun loadConfig(
      @Path(&quot;communityName&quot;) communityName: String
    ): Call&lt;ResponseBody&gt;
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<pre><code class="language-kotlin" data-line-numbers="3-4">@TaskAction
fun execute() { 
 val api: NativeConfigApi = configCredentials.nativeConfigApi(logger)
 val response = nativeConfigApi.loadConfig(community.get()).execute()
 val output = outArtifact.get().asFile
 output.parentFile.mkdirs()
 output.sink().buffer().use { sink -&gt;
     val source = response.body()?.source()
     sink.writeAll(source)
 }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<pre><code class="language-kotlin" data-line-numbers="5-11">@TaskAction
fun execute() { 
 val api: NativeConfigApi = configCredentials.nativeConfigApi(logger)
 val response = nativeConfigApi.loadConfig(community.get()).execute()
 val output = outArtifact.get().asFile.apply {
  parentFile.mkdirs()
 }
 output.sink().buffer().use { sink -&gt;
   val source = response.body()?.source()
   sink.writeAll(source)
 }
}
</code></pre>
</section><section>
<h3 id="transform-extension-functions">Transform Extension Functions</h3>
<pre><code class="language-kotlin" data-line-numbers>fun Provider&lt;RegularFile&gt;.toNativeConfig(): Provider&lt;NativeConfig&gt; =
  map { it.asFile.toNativeConfig() }

fun File.toNativeConfig(): NativeConfig {
  // load json from file
}

data class NativeConfig(
  val communityId: String,
  /* ... */
)
</code></pre>

</section>
</section><section>


<section data-shortcode-section>
<h3 id="renaming-apk-appid-versioncode-versionname">Renaming APK, <strong>appId</strong>, <strong>versionCode</strong>, <strong>versionName</strong></h3>
</section><section>
<h3 id="steps">Steps</h3>
<p><span class='fragment ' >Initiate a network call to retrieve the app’s remote configuration.</span></p>
<p><span class='fragment ' >Configure <strong>appId</strong> using this remote configuration.</span></p>
<p><span class='fragment ' >Set up <strong>versionCode</strong> and <strong>versionName</strong> using environment variables.</span></p>
<p><span class='fragment ' >Finally, connect providers to Variant/Output types.</span></p>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="hooking-into-onvariants">Hooking into onVariants</h3>
<pre><code class="language-kotlin" data-line-numbers="1-4">fun ApplicationAndroidComponentsExtension.renameApk(
  projet: Project,
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;,
) = onVariants { variant -&gt;
  val outputsImpl = variant.outputs.filterIsInstance&lt;VariantOutputImpl&gt;()
  val outputImpl = outputsImpl.firstOrNull { output -&gt; output.fullName == variant.name }!!
  
  OutputProviders.for(project, &quot;apk&quot;, outputImpl, loadRemoteConfig).apply {
  	applyTo(output)
  	applyTo(variant)
  }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="hooking-into-onvariants-1">Hooking into onVariants</h3>
<pre><code class="language-kotlin" data-line-numbers="5-6">fun ApplicationAndroidComponentsExtension.renameApk(
  projet: Project,
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;,
) = onVariants { variant -&gt;
  val outputsImpl = variant.outputs.filterIsInstance&lt;VariantOutputImpl&gt;()
  val outputImpl = outputsImpl.firstOrNull { output -&gt; output.fullName == variant.name }!!
  
  OutputProviders.forApk(project, outputImpl, loadRemoteConfig).apply {
  	applyTo(output)
  	applyTo(variant)
  }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="hooking-into-onvariants-2">Hooking into onVariants</h3>
<pre><code class="language-kotlin" data-line-numbers="8-10">fun ApplicationAndroidComponentsExtension.renameApk(
  projet: Project,
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;,
) = onVariants { variant -&gt;
  val outputsImpl = variant.outputs.filterIsInstance&lt;VariantOutputImpl&gt;()
  val outputImpl = outputsImpl.firstOrNull { output -&gt; output.fullName == variant.name }!!
  
  OutputProviders.for(project, &quot;apk&quot;, outputImpl, loadRemoteConfig).apply {
  	applyTo(output)
  	applyTo(variant)
  }
}
</code></pre>
</section><section>
<h3 id="references-custom-providers-for-renaming-artifacts">References custom providers for renaming artifacts</h3>
<pre><code class="language-kotlin" data-line-numbers>internal class OutputProviders(
  val appId: Provider&lt;String&gt;,
  val versionName: Provider&lt;String&gt;,
  val versionCode: Provider&lt;Int&gt;,
  val outputFileName: Provider&lt;String&gt;,
)
</code></pre>
</section><section>
<h3 id="version-name">Version Name</h3>
<pre><code class="language-kotlin" data-line-numbers>fun getVersionName(project: Project): Provider&lt;String&gt; {
 val propProvider = project.providers.gradleProperty(&quot;versionName&quot;)

 project.providers
  .environmentVariable(&quot;VERSION_NAME&quot;)
  .orElse(propProvider)
  .orElse(&quot;UNSET&quot;)
}
</code></pre>
</section><section>
<h3 id="version-code">Version Code</h3>
<pre><code class="language-kotlin" data-line-numbers>fun getVersionCode(project: Project): Provider&lt;String&gt; {
 val propProvider = project.providers.gradleProperty(&quot;versionCode&quot;)
 
 project.providers
  .environmentVariable(&quot;VERSION_CODE&quot;)
  .orElse(propProvider)
  .parseIntOrDefault(0)
}
</code></pre>
</section><section>
<h3 id="from-cli">From CLI</h3>
<pre><code class="language-bash">./gradlew :app:assemble \
    -Pcommunity=androidbudapest \
    -PversionName=1.0.0 \
    -PversionCode=1
</code></pre>
</section><section>
<h3 id="on-ci">On CI</h3>
<pre><code class="language-bash">- name: Build APP
  shell: bash
  env:
    COMMUNITY: ${{needs.env-setup.outputs.community}}
    VERSION_CODE: ${{needs.env-setup.outputs.version_code}}
    VERSION_NAME: ${{needs.env-setup.outputs.version_name}}
  run: |
    ./gradlew :app:assemble
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="application-id">Application ID</h3>
<pre><code class="language-kotlin" data-line-numbers="7-8">fun for(
  project: Project,
  ext: String,
  fullName: String,
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;,
): OutputProviders {
  val getAppId = loadRemoteConfig.flatMap { task -&gt;
	 task.outArtifact.flatMap { output -&gt;
	   project.provider { 
	     output.asFile.toNativeConfig().applicationId 
     }
	 }
  }
  // ...
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="application-id-1">Application ID</h3>
<pre><code class="language-kotlin" data-line-numbers="9-12">fun for(
  project: Project,
  ext: String,
  fullName: String,
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;,
): OutputProviders {
  val getAppId = loadRemoteConfig.flatMap { task -&gt;
	 task.outArtifact.flatMap { output -&gt;
	   // @since 8.1.1
	   project.provider { 
	     output.asFile.toNativeConfig().applicationId 
     }
	 }
  }
  // ...
</code></pre>
</section><section>
<h3 id="migration-to-agp-811-">Migration to AGP 8.1.1 🙄</h3>
<p>Wrapping the file access with a provider is necessary because the
AGP Analytics service evaluates <code>outArtifact</code> during the configuration phase.
Since the file does not yet exist, this causes the build to fail.</p>
</section><section>
<h3 id="final-output-file-name">Final Output File Name</h3>
<pre><code class="language-kotlin" data-line-numbers="3-9">val getVersionName = getVersionName(project)
val getVersionCode = getVersionCode(project)
val getOutputFileName = getVersionName.flatMap { versionName -&gt;
 getVersionCode.flatMap { versionCode -&gt;
  getAppId.map { applicationId -&gt;
   &quot;$applicationId-v$versionName($versionCode)-$fullName.$ext&quot;
  }
 }
}
return OutputProviders(
    appId = getAppId,
    versionName = getVersionName,
    versionCode = getVersionCode,
    outputFileName = getOutputFileName
)
</code></pre>
</section><section>
<h3 id="wiring-of-providers-to-variantoutputimpl">Wiring of providers to VariantOutputImpl</h3>
<pre><code class="language-kotlin" data-line-numbers>fun applyTo(output: VariantOutputImpl) {
    output.versionCode.set(versionCode)
    output.outputFileName.set(outputFileName)
    output.versionName.set(versionName)
}
</code></pre>
</section><section>
<h3 id="wiring-of-providers-to-applicationvariant">Wiring of providers to ApplicationVariant</h3>
<pre><code class="language-kotlin" data-line-numbers="1-2">fun applyTo(variant: ApplicationVariant) {
    variant.applicationId.set(appId)
    variant.buildConfigFields.putAll(
        versionCode.map { versionCode -&gt;
            mapOf(
                &quot;BUILD_NUMBER&quot; to BuildConfigField(
                    type = &quot;String&quot;,
                    value = &quot;\&quot;${versionCode}\&quot;&quot;,
                    comment = null
                )
            )
        }
    )
}
</code></pre>

</section>
</section><section>


<section data-shortcode-section>
<h3 id="renaming-bundle">Renaming Bundle</h3>
</section><section>
<h3 id="steps">Steps</h3>
<p><span class='fragment ' >Hook into the <strong>onVariants</strong>.</span></p>
<p><span class='fragment ' >Register the Gradle managed task <strong>RenameBundleTask</strong>.</span></p>
</section><section>
<h3 id="hooking-into-onvariants">Hooking into onVariants</h3>
<pre><code class="language-kotlin" data-line-numbers>the&lt;ApplicationAndroidComponentsExtension&gt;().onVariants { variant -&gt;
    val providers = OutputProviders.for(
      project, &quot;aab&quot;, variant, loadRemoteConfig
    )
    RenameBundleTask.register(project, variant, providers)
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="renaming">Renaming</h3>
<pre><code class="language-kotlin" data-line-numbers="1-7">abstract class RenameBundleTask : DefaultTask() {
    @get:InputFile
    @get:PathSensitive(PathSensitivity.NONE)
    abstract val inArtifact: RegularFileProperty

    @get:OutputFile
    abstract val outArtifact: RegularFileProperty

    @TaskAction
    fun execute() {
      val inputFile = inArtifact.asFile.get()
      inputFile.copyTo(outArtifact.asFile.get(), overwrite = true)
    }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="renaming-1">Renaming</h3>
<pre><code class="language-kotlin" data-line-numbers="9-13">abstract class RenameBundleTask : DefaultTask() {
    @get:InputFile
    @get:PathSensitive(PathSensitivity.NONE)
    abstract val inArtifact: RegularFileProperty

    @get:OutputFile
    abstract val outArtifact: RegularFileProperty

    @TaskAction
    fun execute() {
      val inputFile = inArtifact.asFile.get()
      inputFile.copyTo(outArtifact.asFile.get(), overwrite = true)
    }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="register-task">Register Task</h3>
<pre><code class="language-kotlin" data-line-numbers="1-7">fun register(
    project: Project,
    variant: ApplicationVariant,
    providers: OutputProviders,
): TaskProvider&lt;RenameBundleTask&gt; {
  val taskSuffix = variant.name.replaceFirstChar { it.titlecase(Locale.getDefault()) }
  val renameBundleTask = project.tasks.register&lt;RenameBundleTask&gt;(&quot;renameBundle$taskSuffix&quot;)
  
  variant.artifacts.use(renameBundleTask)
    .wiredWithFiles(
      RenameBundleTask::inArtifact,
      RenameBundleTask::outArtifact
    )
    .toTransform(SingleArtifact.BUNDLE)
  
  renameBundleTask.configure {
      providers.applyTo(outArtifact, outArtifact::fileProvider)
  }
  
  return renameBundleTask
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="wire-task-to-the-artifacts-api">Wire task to the Artifacts API</h3>
<pre><code class="language-kotlin" data-line-numbers="9-14">fun register(
    project: Project,
    variant: ApplicationVariant,
    providers: OutputProviders,
): TaskProvider&lt;RenameBundleTask&gt; {
  val taskSuffix = variant.name.replaceFirstChar { it.titlecase(Locale.getDefault()) }
  val renameBundleTask = project.tasks.register&lt;RenameBundleTask&gt;(&quot;renameBundle$taskSuffix&quot;)
  
  variant.artifacts.use(renameBundleTask)
    .wiredWithFiles(
      RenameBundleTask::inArtifact,
      RenameBundleTask::outArtifact
    )
    .toTransform(SingleArtifact.BUNDLE)
  
  renameBundleTask.configure {
    providers.applyTo(
      artifact = outArtifact,
      out = { file: File -&gt; outArtifact.fileProvider(file) }
    )
  }
  
  return renameBundleTask
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="acquire-agp-plugin-path-of-the-artifact">Acquire AGP plugin path of the artifact</h3>
<pre><code class="language-kotlin" data-line-numbers="16-21">fun register(
    project: Project,
    variant: ApplicationVariant,
    providers: OutputProviders,
): TaskProvider&lt;RenameBundleTask&gt; {
  val taskSuffix = variant.name.replaceFirstChar { it.titlecase(Locale.getDefault()) }
  val renameBundleTask = project.tasks.register&lt;RenameBundleTask&gt;(&quot;renameBundle$taskSuffix&quot;)
  
  variant.artifacts.use(renameBundleTask)
    .wiredWithFiles(
      RenameBundleTask::inArtifact,
      RenameBundleTask::outArtifact
    )
    .toTransform(SingleArtifact.BUNDLE)
  
  renameBundleTask.configure {
    providers.applyTo(
      artifact = outArtifact,
      out = { file: File -&gt; outArtifact.fileProvider(file) }
    )
  }
  
  return renameBundleTask
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="reconfigure-rename-task">Reconfigure rename task</h3>
<pre><code class="language-kotlin" data-line-numbers="1-7">internal class OutputProviders(
    val outputFileName: Provider&lt;String&gt;,
){
  fun applyTo(
    artifact: RegularFileProperty, 
    out: (Provider&lt;File&gt;) -&gt; Unit
  ) {
    val outParent = File(artifact.get().asFile.parent)
    out(outputFileName.map { fileName: String -&gt; File(outParent, fileName) })
  }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="get-bundle-parent-folder-path">Get Bundle parent folder path</h3>
<pre><code class="language-kotlin" data-line-numbers="8">internal class OutputProviders(
    val outputFileName: Provider&lt;String&gt;,
){
  fun applyTo(
    artifact: RegularFileProperty, 
    out: (Provider&lt;File&gt;) -&gt; Unit
  ) {
    val outParent = File(artifact.get().asFile.parent)
    out(outputFileName.map { fileName: String -&gt; File(outParent, fileName) })
  }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="rename-file-based-on-custom-naming-provider">Rename file based on custom naming Provider</h3>
<pre><code class="language-kotlin" data-line-numbers="9">internal class OutputProviders(
    val outputFileName: Provider&lt;String&gt;,
){
  fun applyTo(
    artifact: RegularFileProperty, 
    out: (Provider&lt;File&gt;) -&gt; Unit
  ) {
    val outParent = File(artifact.get().asFile.parent)
    out(outputFileName.map { fileName: String -&gt; File(outParent, fileName) })
  }
}
</code></pre>

</section>
</section><section>


<section data-shortcode-section>
<h3 id="buildconfig-manifest-placeholder-wiring">BuildConfig, Manifest Placeholder wiring</h3>
</section><section>
<h3 id="mappropertyhttpsdocsgradleorgcurrentjavadocorggradleapiprovidermappropertyhtml"><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/MapProperty.html" target="_blank" rel="noopener">MapProperty</a></h3>
<p>Part of <code>org.gradle.api.provider</code>.</p>
<pre><code class="language-kotlin" data-line-numbers>package com.android.build.api.variant

import org.gradle.api.provider.MapProperty
import java.io.Serializable

interface Variant : Component, HasAndroidResources {
  val buildConfigFields: MapProperty&lt;String, BuildConfigField&lt;out Serializable&gt;&gt;
  val manifestPlaceholders: MapProperty&lt;String, String&gt;
}
</code></pre>
</section><section>
<h3 id="variantbuildconfigfields">Variant#buildConfigFields</h3>
<pre><code class="language-kotlin" data-line-numbers="4-13">// OutputProviders.kt
fun applyTo(variant: ApplicationVariant) {
    variant.applicationId.set(appId)
    variant.buildConfigFields.putAll(
        versionCode.map { versionCode -&gt;
            mapOf(
                &quot;BUILD_NUMBER&quot; to BuildConfigField(
                    type = &quot;String&quot;,
                    value = &quot;\&quot;${versionCode}\&quot;&quot;,
                    comment = null
                )
            )
        }
    )
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="variantmanifestplaceholders">Variant#manifestPlaceholders</h3>
<pre><code class="language-kotlin" data-line-numbers="4-5">private fun ApplicationAndroidComponentsExtension.setDeeplinkScheme(
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;
) = onVariants { variant -&gt;
  val placeholders = loadRemoteConfig
      .flatMap { it.outArtifact.toNativeConfig() }
      .map { nativeConfig -&gt;
          mapOf(
              &quot;deepLinkScheme&quot; to nativeConfig.deeplinkScheme,
              &quot;deepLinkHost&quot; to nativeConfig.apiEndpoint
          )
      }
  variant.manifestPlaceholders.putAll(placeholders)
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="variantmanifestplaceholders-1">Variant#manifestPlaceholders</h3>
<pre><code class="language-kotlin" data-line-numbers="6-11">private fun ApplicationAndroidComponentsExtension.setDeeplinkScheme(
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;
) = onVariants { variant -&gt;
  val placeholders = loadRemoteConfig
      .flatMap { it.outArtifact.toNativeConfig() }
      .map { nativeConfig -&gt;
          mapOf(
              &quot;deepLinkScheme&quot; to nativeConfig.deeplinkScheme,
              &quot;deepLinkHost&quot; to nativeConfig.apiEndpoint
          )
      }
  variant.manifestPlaceholders.putAll(placeholders)
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="variantmanifestplaceholders-2">Variant#manifestPlaceholders</h3>
<pre><code class="language-kotlin" data-line-numbers="12">private fun ApplicationAndroidComponentsExtension.setDeeplinkScheme(
  loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;
) = onVariants { variant -&gt;
  val placeholders = loadRemoteConfig
      .flatMap { it.outArtifact.toNativeConfig() }
      .map { nativeConfig -&gt;
          mapOf(
              &quot;deepLinkScheme&quot; to nativeConfig.deeplinkScheme,
              &quot;deepLinkHost&quot; to nativeConfig.apiEndpoint
          )
      }
  variant.manifestPlaceholders.putAll(placeholders)
}
</code></pre>

</section>
</section><section>


<section data-shortcode-section>
<h3 id="modifying-androidmanifest-">Modifying AndroidManifest 🛠️</h3>
<p><span class='fragment ' >Enable or disable <strong>proxy settings</strong> using third-party tools like Charles Proxy.</span></p>
<p><span class='fragment ' >Add or remove <strong>permissions</strong>.</span></p>
<p><span class='fragment ' >Add or remove <strong>services</strong>.</span></p>
</section><section>
<h3 id="general-approach">General Approach</h3>
<p><span class='fragment ' >Create a task where manifest is an <strong>input file</strong>.</span></p>
<p><span class='fragment ' >Connect the task with the Artifacts API via <strong>SingleArtifact.MERGED_MANIFEST</strong>.</span></p>
<p><span class='fragment ' >Parse the XML, modify contents, dump contents to new output file.</span></p>
</section><section>
<h3 id="enabling-charles-proxying">Enabling Charles Proxying</h3>
<p><span class='fragment ' >Register a task to generate <strong>xml/network_security_config.xml</strong>.</span></p>
<p><span class='fragment ' >Link the task to AGP using the <strong>Sources API</strong>.</span></p>
<p><span class='fragment ' >Register a task to append the network_security_config to the AndroidManifest.</span></p>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<pre><code class="language-kotlin" data-line-numbers="1-4">private fun ApplicationAndroidComponentsExtension.setHttpProxy(
    project: Project, 
    loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;
) = onVariants { variant -&gt;
  val tasks = project.tasks
  val genNetworkSecurityConfig = tasks.register&lt;GenNetworkSecurityConfig&gt;(
      name = &quot;create${variant.name.capitalize()}NetworkConfig&quot;
  ) {
      configFile.set(loadRemoteConfig.flatMap { it.outArtifact })
  }
  val appendManifestConfigTask = tasks.register&lt;AppendManifestConfigTask&gt;(
      name = &quot;append${variant.name.capitalize()}ManifestNetworkConfig&quot;
  ) {
      networkConfig.set(genNetworkSecurityConfig.flatMap { it.networkConfig() })
  }
  // ...
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<pre><code class="language-kotlin" data-line-numbers="5-10">private fun ApplicationAndroidComponentsExtension.setHttpProxy(
    project: Project, 
    loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;
) = onVariants { variant -&gt;
  val tasks = project.tasks
  val genNetworkSecurityConfig = tasks.register&lt;GenNetworkSecurityConfig&gt;(
      name = &quot;create${variant.name.capitalize()}NetworkConfig&quot;
  ) {
      configFile.set(loadRemoteConfig.flatMap { it.outArtifact })
  }
  val appendManifestConfigTask = tasks.register&lt;AppendManifestConfigTask&gt;(
      name = &quot;append${variant.name.capitalize()}ManifestNetworkConfig&quot;
  ) {
      networkConfig.set(genNetworkSecurityConfig.flatMap { it.networkConfig() })
  }
  // ...
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<pre><code class="language-kotlin" data-line-numbers="11-15">private fun ApplicationAndroidComponentsExtension.setHttpProxy(
    project: Project, 
    loadRemoteConfig: TaskProvider&lt;LoadRemoteConfig&gt;
) = onVariants { variant -&gt;
  val tasks = project.tasks
  val genNetworkSecurityConfig = tasks.register&lt;GenNetworkSecurityConfig&gt;(
      name = &quot;create${variant.name.capitalize()}NetworkConfig&quot;
  ) {
      configFile.set(loadRemoteConfig.flatMap { it.outArtifact })
  }
  val appendManifestConfigTask = tasks.register&lt;AppendManifestConfigTask&gt;(
      name = &quot;append${variant.name.capitalize()}ManifestNetworkConfig&quot;
  ) {
      networkConfig.set(genNetworkSecurityConfig.flatMap { it.networkConfig() })
  }
  // ...
</code></pre>
</section><section>
<pre><code class="language-kotlin" data-line-numbers>abstract class GenNetworkSecurityConfig : DefaultTask() {
    @get:InputFile
    @get:PathSensitive(PathSensitivity.NONE)
    abstract val configFile: RegularFileProperty

    @get:OutputDirectory
    abstract val resourcesDir: DirectoryProperty
    
    fun networkConfig(): Provider&lt;RegularFile&gt; {
        return resourcesDir.map { dir -&gt; dir.file(&quot;xml/network_security_config.xml&quot;) }
    }
</code></pre>
</section><section>
<pre><code class="language-kotlin" data-line-numbers>abstract class AppendManifestConfigTask : DefaultTask() {
    @get:InputFile
    @get:PathSensitive(PathSensitivity.NONE)
    abstract val networkConfig: RegularFileProperty

    @get:InputFile
    @get:PathSensitive(PathSensitivity.NONE)
    abstract val mergedManifest: RegularFileProperty

    @get:OutputFile
    abstract val updatedManifest: RegularFileProperty
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="appendmanifestconfigtask">AppendManifestConfigTask</h3>
<pre><code class="language-kotlin" data-line-numbers="3-6">@TaskAction
fun taskAction() {
  val manifest = mergedManifest.asFile.get()
  val manifestXml = DocumentBuilderFactory.newInstance()
      .newDocumentBuilder()
      .parse(manifest)
      
  val manifestTag = manifestXml.getElementsByTagName(&quot;application&quot;).item(0)
  if (manifestTag.nodeType == Node.ELEMENT_NODE) {
      val element = manifestTag as Element
      if (element.hasAttribute(&quot;android:networkSecurityConfig&quot;)) {
          element.removeAttribute(&quot;android:networkSecurityConfig&quot;)
      }
      
      val refName = networkConfig.asFile.get().name.let { fileName -&gt;
        fileName.substring(0, fileName.lastIndexOf('.'))
      }
      element.setAttribute(&quot;android:networkSecurityConfig&quot;, &quot;@xml/$refName&quot;)
  }

  val transformer = TransformerFactory.newInstance().newTransformer()
  val newManifest = updatedManifest.get().asFile
  transformer.transform(DOMSource(manifestXml), StreamResult(newManifest))
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="appendmanifestconfigtask-1">AppendManifestConfigTask</h3>
<pre><code class="language-kotlin" data-line-numbers="8-19">@TaskAction
fun taskAction() {
  val manifest = mergedManifest.asFile.get()
  val manifestXml = DocumentBuilderFactory.newInstance()
      .newDocumentBuilder()
      .parse(manifest)
      
  val manifestTag = manifestXml.getElementsByTagName(&quot;application&quot;).item(0)
  if (manifestTag.nodeType == Node.ELEMENT_NODE) {
      val element = manifestTag as Element
      if (element.hasAttribute(&quot;android:networkSecurityConfig&quot;)) {
          element.removeAttribute(&quot;android:networkSecurityConfig&quot;)
      }
      
      val refName = networkConfig.asFile.get().name.let { fileName -&gt;
        fileName.substring(0, fileName.lastIndexOf('.'))
      }
      element.setAttribute(&quot;android:networkSecurityConfig&quot;, &quot;@xml/$refName&quot;)
  }

  val transformer = TransformerFactory.newInstance().newTransformer()
  val newManifest = updatedManifest.get().asFile
  transformer.transform(DOMSource(manifestXml), StreamResult(newManifest))
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="appendmanifestconfigtask-2">AppendManifestConfigTask</h3>
<pre><code class="language-kotlin" data-line-numbers="21-23">@TaskAction
fun taskAction() {
  val manifest = mergedManifest.asFile.get()
  val manifestXml = DocumentBuilderFactory.newInstance()
      .newDocumentBuilder()
      .parse(manifest)
      
  val manifestTag = manifestXml.getElementsByTagName(&quot;application&quot;).item(0)
  if (manifestTag.nodeType == Node.ELEMENT_NODE) {
      val element = manifestTag as Element
      if (element.hasAttribute(&quot;android:networkSecurityConfig&quot;)) {
          element.removeAttribute(&quot;android:networkSecurityConfig&quot;)
      }
      
      val refName = networkConfig.asFile.get().name.let { fileName -&gt;
        fileName.substring(0, fileName.lastIndexOf('.'))
      }
      element.setAttribute(&quot;android:networkSecurityConfig&quot;, &quot;@xml/$refName&quot;)
  }

  val transformer = TransformerFactory.newInstance().newTransformer()
  val newManifest = updatedManifest.get().asFile
  transformer.transform(DOMSource(manifestXml), StreamResult(newManifest))
}
</code></pre>

</section>
</section><section>


<section data-shortcode-section>
<h3 id="downloading-app-icons">Downloading App Icons</h3>
</section><section>
<p>Retrieve the Cloudinary key.</p>
<p><span class='fragment ' >Construct links following the predefined specifications.</span></p>
<p><span class='fragment ' >Generate a <strong>WorkAction</strong> based on the URL.</span></p>
<p><span class='fragment ' >Each <strong>WorkAction</strong> establishes an HTTP connection and writes the content to a file.</span></p>
<p><span class='fragment ' >The task is connected using the <strong>Sources</strong> API from the <strong>Variant</strong> object.</span></p>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="register-loadassetstask">Register LoadAssetsTask</h3>
<pre><code class="language-kotlin" data-line-numbers="1-7">val community = devCommunityExtension.resolveName(project).get()
val communityName = community.replaceFirstChar { it.titlecase(Locale.US) }
val task = tasks.register&lt;LoadAssetsTask&gt;(
  name = &quot;${variant.name}${communityName}CommunityAssets&quot;
) {
    nativeConfigFile.set(loadRemoteConfig.flatMap { it.outArtifact })
}
variant.sources.res?.addGeneratedSourceDirectory(
    task,
    LoadAssetsTask::resourcesDir
)
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="register-loadassetstask-1">Register LoadAssetsTask</h3>
<pre><code class="language-kotlin" data-line-numbers="8-11">val community = devCommunityExtension.resolveName(project).get()
val communityName = community.replaceFirstChar { it.titlecase(Locale.US) }
val task = tasks.register&lt;LoadAssetsTask&gt;(
  name = &quot;${variant.name}${communityName}CommunityAssets&quot;
) {
    nativeConfigFile.set(loadRemoteConfig.flatMap { it.outArtifact })
}
variant.sources.res?.addGeneratedSourceDirectory(
    task,
    LoadAssetsTask::resourcesDir
)
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="action">Action</h3>
<pre><code class="language-kotlin" data-line-numbers>with(nativeConfigFile.toNativeConfig().get()) {
  with(Cloudinary(cloudinaryUrl)) {
    loadIconLauncher(assetAppIcon)
    assetNotificationIcon?.let { loadIconNotification(it) }
    assetHeaderLogo?.let { loadHeaderLogo(it) }
    assetLaunchScreen?.let { loadBackgroundSplash(it) }
  }
}
</code></pre>
</section><section>
<h3 id="load-launcher-icon">Load Launcher Icon</h3>
<pre><code class="language-kotlin" data-line-numbers>private fun Cloudinary.loadIconLauncher(publicId: String) 
 = downloadAssets(
  publicId = publicId,
  bundle = mapOf(
      &quot;drawable-hdpi/ic_launcher.png&quot; to {
          add(Resize.fill { width(72).run { height(72) } }.mixInColorSpace())
          extension(Format.png())
      }
 // Other specs
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="query-work-to-queue">Query work to queue</h3>
<pre><code class="language-kotlin" data-line-numbers="1-4">private fun Cloudinary.downloadAssets(
  publicId: String, 
  bundle: Map&lt;String, Image.Builder.() -&gt; Unit&gt;
) {
  val workQueue = getWorkerExecutor().noIsolation()
  bundle.forEach { (path, imagePresets) -&gt;
   val asset = image {
       publicId(publicId)
       imagePresets(this)
   }
   val downloadUrl = asset.generate()
   workQueue.submit(WorkItem::class.java) {
       outputFile.set(resourcesDir.file(path))
       url.set(downloadUrl)
   }
  }
}
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="query-work-to-queue-1">Query work to queue</h3>
<pre><code class="language-kotlin" data-line-numbers="5">private fun Cloudinary.downloadAssets(
  publicId: String, 
  bundle: Map&lt;String, Image.Builder.() -&gt; Unit&gt;
) {
  val workQueue = getWorkerExecutor().noIsolation()
  bundle.forEach { (path, imagePresets) -&gt;
   val asset = image {
       publicId(publicId)
       imagePresets(this)
   }
   val downloadUrl = asset.generate()
   workQueue.submit(WorkItem::class.java) {
       outputFile.set(resourcesDir.file(path))
       url.set(downloadUrl)
   }
  }
}
</code></pre>
</section><section>
<h3 id="workerexecutor">WorkerExecutor</h3>
<pre><code class="language-kotlin" data-line-numbers="9-10">abstract class LoadAssetsTask : DefaultTask() {
    @get:InputFile
    @get:PathSensitive(PathSensitivity.NONE)
    abstract val nativeConfigFile: RegularFileProperty

    @get:OutputDirectory
    abstract val resourcesDir: DirectoryProperty

    @Inject
    abstract fun getWorkerExecutor(): WorkerExecutor

    @TaskAction
    fun execute() {
      // Do the magic 🪄
    }
}
</code></pre>
</section><section>
<h3 id="a-task-within-task-">A task within task 🤔?</h3>
<p><strong>Unit of work</strong> that is distributed across available processes.</p>
<figure><img src="/notes-vault/agp-500/images/writing-tasks-5.png"><figcaption>
      <h4>Parallel Execution</h4>
    </figcaption>
</figure>
</section>
<section data-noprocess data-shortcode-slide
      data-transition="none"
      data-transition-speed="fast">
<h3 id="query-work-to-queue-2">Query work to queue</h3>
<pre><code class="language-kotlin" data-line-numbers="6-16">private fun Cloudinary.downloadAssets(
  publicId: String, 
  bundle: Map&lt;String, Image.Builder.() -&gt; Unit&gt;
) {
  val workQueue = getWorkerExecutor().noIsolation()
  bundle.forEach { (path, imagePresets) -&gt;
   val asset = image {
       publicId(publicId)
       imagePresets(this)
   }
   val downloadUrl = asset.generate()
   workQueue.submit(WorkItem::class.java) {
       outputFile.set(resourcesDir.file(path))
       url.set(downloadUrl)
   }
  }
}
</code></pre>
</section><section>
<h3 id="workitem">WorkItem</h3>
<pre><code class="language-kotlin" data-line-numbers>interface WorkItemParameters : WorkParameters, Serializable {
    val outputFile: RegularFileProperty
    val url: Property&lt;String&gt;
}

abstract class WorkItem @Inject constructor() : WorkAction&lt;WorkItemParameters&gt; {
  override fun execute() {
    val parameters: WorkItemParameters = parameters
    // 1. Create file
    // 2. Make a network call 
    // 3. Write content to the file
  }
}
</code></pre>

</section>
</section><section>
<h3 id="conclusions">Conclusions</h3>
<p>

<span class='fragment ' >Use <strong>variant.sources</strong> API to generate resources.</br></span>




<span class='fragment ' >Use <strong>variant.artifacts</strong> API to fetch artifacts.</br></span>




<span class='fragment ' >Use <strong>variant.artifacts</strong> API to alter artifacts (e.g., AndroidManifest).</br></span>




<span class='fragment ' >Utilize the <strong>Property</strong> and <strong>Provider</strong> APIs for lazy evaluation and implicit dependencies.</br></span>




<span class='fragment ' >Employ <strong>WorkerExecutor</strong> for parallelizing tasks.</br></span>

</p>
</section><section>
<h3 id="qa">QA</h3>
<div class="qr-columns">
    <div class="qr-item">
        <div id="me" class="qr"></div>
        <h4>Get in Touch</h4>
    </div>
    <div class="qr-item">
        <div id="thisPresentation" class="qr"></div>
        <h4>This presentation</h4>
    </div>
</div>
<script>
    new QRCode(document.getElementById("me"), {
        text: "https://bento.me/tomkoptel",
        width: 200,
        height: 200,
    });
    new QRCode(document.getElementById("thisPresentation"), {
        text: "https://tomkoptel.github.io/notes-vault/agp-500/",
        width: 200,
        height: 200,
    });
</script>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/notes-vault/reveal-hugo/object-assign.js></script>


<script src="/notes-vault/reveal-js/dist/reveal.js"></script>


  <script type="text/javascript" src="/notes-vault/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/notes-vault/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/notes-vault/reveal-js/plugin/zoom/zoom.js"></script>
  
  <script type="text/javascript" src="/notes-vault/reveal-js/plugin/notes/notes.js"></script>
  
<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }

  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = {};
  var revealHugoPageParams = {"highlight_theme":"night-owl","slide_number":true,"theme":"dracula","transition":"slide"};

  var revealHugoPlugins = {
    
    plugins: [RevealMarkdown,RevealHighlight,RevealZoom,RevealNotes]
  };

  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams),
    camelize(revealHugoPlugins));

  Reveal.initialize(options);
</script>





  
  

  
  

  
  

  
  





    
    
  </body>
</html>
